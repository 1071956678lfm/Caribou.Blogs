## 原则

### 开闭原则 OCP ：

```
开闭原则的含义是说一个软件实体应该通过扩展来实现变化，而不是通过修改已有代码来实现变化。
对扩展开放，对修改关闭
```

**1. 它们 "面向扩展开放（Open For Extension）"。**

也就是说模块的行为是能够被扩展的。当应用程序的需求变化时，我们可以使模块表现出全新的或与以往不同的行为，以满足新的需求。

**2. 它们 "面向修改封闭（Closed For Modification）"。**

模块的源代码是不能被侵犯的，任何人都不允许修改已有源代码。

#### 反例：

1. 面对不同的子类，不采取合适的继承方式
2. 过多的分支

### 迪米特法则

```
一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法
```

初衷是降低类之间的**耦合**，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系

应当改用 **委托**

#### 违反

1. 级联调用 `A.B.C().d()`
2. 方法内部包含各种其他类的一些方法调用

### 接口分离原则 ISP

```
接口分离原则（Interface Segregation Principle）用于处理胖接口（fat interface）所带来的问题。
如果类的接口定义暴露了过多的行为，则说明这个类的接口定义内聚程度不够好。

换句话说，类的接口可以被分解为多组功能函数的组合，每一组都服务于不同的客户类，而不同的客户类可以选择使用不同的功能分组。

%%%  客户类不应被强迫依赖那些它们不需要的接口
```

关键在于**减少不必要的依赖和耦合**

### 单一职责原则

```
一个类应该有且只有一个变化的原因。
如果你能想出多于一种动机来更改一个类，则这个类就包含多于一个职责
```

### 里氏替换原则 LSP

```
开放封闭原则（Open Closed Principle）
是构建可维护性和可重用性代码的基础。它强调设计良好的代码可以不通过修改而扩展，新的功能通过添加新的代码来实现，而不需要更改已有的可工作的代码。抽象（Abstraction）和多态（Polymorphism）是实现这一原则的主要机制，而继承（Inheritance）则是实现抽象和多态的主要方法。

里氏替换原则（LSP: The Liskov Substitution Principle）
使用基类对象指针或引用的函数必须能够在不了解衍生类的条件下使用衍生类的对象。
```

为了仍然遵守 LSP 原则，并同时符合 OCP 原则，**所有的衍生类必须符合使用者所期待的基类的行为**

###### conclusion

[开放封闭原则（Open Closed Principle）](http://www.cnblogs.com/gaochundong/p/open_closed_principle.html)是许多面向对象设计启示思想的核心。符合该原则的应用程序在可维护性、可重用性和鲁棒性等方面会表现的更好。[里氏替换原则（Liskov Substitution Principle）](http://www.cnblogs.com/gaochundong/p/liskov_substitution_principle.html)则是实现 OCP 原则的**重要方式**。只有当衍生类能够完全替代它们的基类时，使用基类的函数才能够被安全的重用，然后衍生类也可以被放心的修改了。

- 子类方法的**前置条件**，比超类的前置条件更**弱**
- 子类的**后置条件**，比超类的后置条件更**多**

### 数据与行为集中原则

```
对于一个类的操作，他的行为与数据应当尽可能在一起绑定
```

### 组合优于继承

```
只有在继承机制产生副作用时(违反LSP),并且需要复用部分代码实现时需要该原则
```

### 针对接口编程

```
核心:建立类的契约，并根据契约理解和使用类
```

### 依赖倒置原则

**DIP**

```
抽象不应该依赖于细节，细节应该依赖于抽象
高层模块不应该依赖底层模块，而是双方都应该依赖抽象
```

