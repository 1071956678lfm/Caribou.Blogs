# 详细设计

## 详细设计基础

### 概述

#### 详细设计

```
体系结构设计中主要关注高层设计
详细设计中一般进行中层设计和底层设计
```

中层设计：模块内部结构(数据定义、函数定义、类定义、类结构)

底层设计：深入模块和类内部，关注具体的数据结构、算法、类型、语句和控制结构

#### 详细设计的上下文

```
作为输入的需求&体系结构接口定义
```

### 结构化设计

思想：**分解**

#### 职责

```
职责指
执行任务(operational responsibility)和维持数据(data responsibility)
```

- **任务**职责由运算实现

- **数据**职责由属性实现

##### 职责驱动的分解

职责从不同高度的抽象开始，进行分解；

高层职责被指派给高层组件；职责反映了行为与数据的义务——不同的分解导致不同的职责分配

##### 启发式职责

- 高内聚、低耦合
- 职责不会重叠
- 将行为和职责放置在模块，使他们正好可以实现模块的职责

##### 委托

```
一个模块将职责转交给另一个模块
```

### 面向对象设计

思想：协作

#### 面向对象设计的过程

##### 通过职责建立静态模型

###### 类之间的关系

| 关系     | 关系短语         | 解释                                                         |
| -------- | ---------------- | ------------------------------------------------------------ |
| 依赖     | A use B          | 被依赖的对象只是作为一种工具使用<br/>其引用不被A持有         |
| 普通关联 | A has B          | A长期持有另一个对象的引用<br/>关联的两个对象彼此之间没有任何强制性的约束 |
| 聚合     | A own B          | 集合所属关系<br/>B还可以被其他对象关联；被聚合对象可以被共享 |
| 组合     | B is a part of A | **生命周期**要求相同<br/>允许被包含对象B被共享<br/>不存在两个包含对象被同一个被包含对象的共享 |
| 继承     | B is A           |                                                              |
| 实现     | B implements A   |                                                              |

###### 添加辅助类

```
候选类不可能实现所有的功能，所以可能还需要添加一些辅助类
```

##### 通过协作建立动态模型

###### 对象创建

| 场景 | 创建地点 | 创建时机 | 备注 |
| ---- | -------- | -------- | ---- |
|      |          |          |      |
|      |          |          |      |
|      |          |          |      |
|      |          |          |      |

###### 控制风格

- 集中式

```
做决策的往往只有一个对象；由这个对象来决定如何进行职责分配
```

- 委托式

```
做出决策的对象不止一个
```

- 分散式

```
每个对象承担一个相对较小的职责；完全靠各个对象自治的方式来实现较大的职责
```

## 模块化和信息隐藏

### 模块化和信息隐藏思想

```
高内聚，低耦合
```

### 模块化

#### 分解与模块化

##### 模块

```
是一个词汇上邻接的程序语句序列，由边界元素限制范围，有一个聚合标志符
```

耦合

![img](https://raw.githubusercontent.com/1071956678lfm/blogs/master/%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0/%E8%BD%AF%E5%B7%A5%E4%BA%8C/%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1/%E8%80%A6%E5%90%88%E7%B1%BB%E5%9E%8B.png)

- 控制耦合关于 **控制逻辑**的共享
- 印记耦合关于 **数据结构** 的共享
- 数据耦合关于 **数据** 的共享



##### 内聚

![img](https://raw.githubusercontent.com/1071956678lfm/blogs/master/%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0/%E8%BD%AF%E5%B7%A5%E4%BA%8C/%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1/%E5%86%85%E8%81%9A%E7%B1%BB%E5%9E%8B.png)

### 信息隐藏

#### 抽象与信息隐藏

##### 抽象

```
总结提炼本质特征，消除非本质的细节，从而使得人们可以聚焦在本质上，降低认知复杂性
```

抽象出来的是接口，隐藏的是实现，他们共同体现了模块的职责

##### 模块的主要秘密

- 主要秘密描述的是这个模块所要实现的⽤用户需求。是设计者对⽤用户需求的实现的⼀一次职责分配。有了了这个描述以后，我们可以利利⽤用它检查我们是否完成所有的⽤用户需求，还可以利利⽤用它和需求优先级来决定开发的次序。

##### 模块的次要秘密

- 次要秘密描述的是这个模块在实现职责时候所涉及的具体的实现细节。包括数据结构，算法，硬件平台等信息。

## 详细设计中的模块化

### 面向对象中的模块

#### 类

- 模块化希望代码片段由 **接口和实现** 组成
- 接口包括供接口和需接口
  - 供接口：函数的声明，是供别人使用的契约
  - 需接口：实现中调用的其他函数，是使用他人的契约

### 访问耦合

![è®¿é®è¦å.png](https://github.com/1071956678lfm/blogs/blob/master/%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0/%E8%BD%AF%E5%B7%A5%E4%BA%8C/%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1/%E8%AE%BF%E9%97%AE%E8%80%A6%E5%90%88.png?raw=true)

#### 降低访问耦合的方法

##### 1.针对接口编程

按照契约式设计理论，一个类的契约不仅包括它的供接口和需接口，还要详细定义其供接口和需接口的 **前置条件，后置条件和不变式**

针对接口编程的原则就是基于 **细化后的类契约** 进行设计工作

##### 2.接口最小化 / 接口分离原则

##### 3.访问耦合的合理范围 / 迪米特法则

### 继承耦合

![ç»§æ¿è¦å.png](https://github.com/1071956678lfm/blogs/blob/master/%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0/%E8%BD%AF%E5%B7%A5%E4%BA%8C/%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1/%E7%BB%A7%E6%89%BF%E8%80%A6%E5%90%88.png?raw=true)

#### 降低继承耦合的方法

##### 1.里氏替换原则 

`LSP`

- 子类方法的**前置条件**，比超类的前置条件更**弱**
- 子类的**后置条件**，比超类的后置条件更**多**

##### 2.使用组合替代继承

### 内聚

#### 面向对象中的内聚

```
分为 方法中的内聚、类的内聚、子类与父类的继承内聚
```

#### 提高内聚的方法

##### 1.集中信息与行为

```
类的信息应该和访问这些信息的行为放在一个类中
```

##### 2.单一职责原则

```
信息与行为除了要集中，还要联合起来表达一个内聚的概念，而不是单纯的堆砌
```

## 详细设计中的信息隐藏

