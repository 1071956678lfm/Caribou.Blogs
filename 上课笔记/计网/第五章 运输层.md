#### 运输层

### 运输层协议概述

#### 进程间通信

```html
运输层向上层的应用层提供通信服务
```

##### 与网络层比较

| 项目         | 运输层                                                       | 网络层                                                       |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 数据交换对象 | 提供进程间的逻辑通信                                         | 提供主机间的逻辑通信                                         |
| 复用和分用   | 复用：发送方不同的进程通过同一个运输层协议传送数据<br/>分用：接收方的运输层在剥去报文首部之后能够把数据正确交付指定进程 | 复用：发送方不同协议的数据可以封装成IP数据报发送<br/>分用：接收方网络层根据IP首部的协议字段进行分用，把剥去首部的数据交付给应当接收这些数据的协议 |
|              | 主机间交互                                                   | 中间的路由器只有下三层                                       |
| 差错检测     | 对数据差错检测                                               | 仅对**首部**进行差错检测                                     |
| 运输协议     | 面向连接的TCP、无连接的UDP<br/>当使用TCP，逻辑通信信道是一条**全双工的可靠信道**<br/>当使用UDP，是一条**不可靠**信道 |                                                              |
| 传输单元     | 报文段                                                       | IP数据报                                                     |

##### 主要协议

`UDP`: User Datagram Protocol 用户数据报协议

`TCP`: Transmission Control Protocol 传输控制协议

##### 传输单元名称

OSI中 : 两个对等传输实体的传送数据单元 ：`TPDU`**运输协议数据单元**(Transport Protocol Data Unit)

TCP / IP中 :**TCP 报文段 / UDP用户数据报** 

##### 运输层的端口

```
协议端口号 Protocol Port Number
```

- 运输层传递的终点为 `目的主机的进程`。只需要将数据报传输到**端口**，接下来的工作由 **TCP , UDP**来实现

这里的端口指的是 **软件端口**

###### 端口号的分类

- 服务器端的端口号
  - 熟知端口号 / 系统端口号
  - 登记端口号
- 客户端的端口号 / 短暂端口号

### 用户数据报协议

#### 概述

- **无连接**。发送之前不需要建立连接
- 尽最大努力交付；不保证可靠交付
- 面向报文；只增加 / 删除报文首部
- **没有阻塞控制**：网络出现的阻塞不会使源主机的发送速率受到影响
- 支持 `一对一、一对多、多对多`的交互通信
- 首部开销小 ： **8字节**

#### 首部格式

![](<https://img-blog.csdn.net/20160318110857394>)

含有 **数据字段**和 **首部字段**；

##### 首部字段

8字节；由4个子字段组成( 2 * 4 )

| 字段     | 特点                                               |
| -------- | -------------------------------------------------- |
| 源端口   | 在需要对方回信时选用；不需要为 **全0**             |
| 目的端口 | 终点交付报文时必须使用                             |
| 长度     | UDP用户数据报长度(最小为8 --- 仅有首部)            |
| 检验和   | 检测UDP用户数据报在传输时是否出错；<br/>出错就丢弃 |

##### 伪首部

- UDP在进行**检验和**计算时，需要在用户数据报之前加入 **12字节**的伪首部；
- 既不向上传递，也不向下传递
- IP数据报
  - 只检验首部
- UDP数据报
  - 检验全部的数据报数据；
  - **步骤**：
    - 检验和置全0
    - 如果数据部分不是偶数个字节：填入一个全0字节(但是不传输)
    - 二进制反码运算  (每16位 / 2 字节)
    - 和数 取反码；存入检验和
    - 接收方：用户数据报 & 伪首部 每16位反码求和；取反码；
      - 如果全0 ，那么没有差错
      - 否则丢弃 / 或者传到上层，并且附上出差错的警告

### TCP协议概述

#### 主要特点

1. 面向连接
2. 点对点，依赖两个端口
3. 提供**可靠**交付
4. 提供全双工通信
5. 面向字节流

```
'流'是指流入/流出到进程的字节序列
'面向字节流'指的是虽然应用程序和TCP交互是一个一个大小不等的数据块，但是TCP把应用程序交下来的数据仅仅看成是一连串无结构的字节流；TCP不需要知道字节流的含义
```

###### 报文长度

- TCP报文的长度不需要关心应用程序将多长的数据传入 **TCP缓存**，而是根据当前窗口值和网络阻塞情况来进行传输
- UDP的报文长度根据应用程序给定的**长度字段**决定

#### TCP的连接

```
TCP连接的端点是  套接字 (socket)
端口号拼接到IP地址即组成了套接字
```

### 可靠传输的原理

```
理想的传输：
1. 传输信道不发生差错
2. 不论发送方的数据发送速度多快，接收方总是来得及接受
```

#### 停止等待协议

把可靠传输等的传输单元称为  **分组**

##### 自动重传请求ARQ

```
Automatic Repeat reQuest
```

我们假设 $A$为发送方，$B$为接收方

| 类型               | 特点                                                         |
| ------------------ | ------------------------------------------------------------ |
| 无差错情况         | $A$发送分组$M_1​$,发完之后暂停发送<br/>直到接收到$B​$的确认    |
| 出现差错           | $A$发送分组$M_1​$，超过了一段时间$t > t_0​$，那么就需要**超时重传**<br/>$t_0​$为超时计数器的限定时间；一般情况，需要**大于收到确认消息的时间**<br/>需要注意：<br/>1. 发送完分组后，需要保留一个**分组副本**(在超时重传的时候使用)<br/>2. 分组与确认分组都需要进行**编号**，用来一 一对应<br/>3. 计时器重传时间需要大于分组传输的平均往返时间 |
| 确认丢失和确认迟到 | 情况1：<br/>1. 确认丢失之后：<br/>区分A的发送分组丢失 or B的确认分组丢失<br/>$B$的确认分组丢失的时候，再次收到同一个分组，那么就**丢弃**，并且返回**确认分组**<br/>2. 确认迟到时：<br/>$A$将会接收到多个重复确认分组；$A$收到后就丢弃重复分组 |
| 信道利用率         | 为了提高传输效率，采取 **流水线传输**(连续ARQ协议 / 滑动窗口协议) |

#### 流水线传输

##### 连续`ARQ`协议

```
发送方每接收到一个确认，就把发送窗口向前滑动一个分组的位置
```

![](<https://upload-images.jianshu.io/upload_images/3145898-e4e6f053f1b9d8ce.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/451/format/webp>)

###### 发送窗口

```
位于发送窗口内的分组连续发送，不需要考虑确认分组
```

###### 累积确认

```
接收方仅对按序到达的最后一个分组发送确认
```

###### 分析

优点：容易实现，即使确认丢失也不需要重传

缺点：不能向发送方反映出已经接收所有分组信息

### TCP报文首部格式

![](<https://img-blog.csdn.net/20131019111917546?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2lsc29ucGVuZzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast>)

| 名称            | 特点                                                         | 长度           |
| --------------- | ------------------------------------------------------------ | -------------- |
| 源端口/目的端口 | 写入分组传入的目标端口                                       | 各2字节        |
| 序号            | 使用 $\mod{2^{32}}$运算<br/>TCP传输的字节流每一个字节**按顺序编号**<br/>也称为**报文段序号** | 4字节          |
| 确认号          | 期望收到对方下一个报文段的第一个数据字节的序号<br/>例如：$A$发送一个 **501** 序列号的报文段，<br/>数据长度 **200** . 因此，$B$期望下一个报文段的序列号为 **701** | 4字节          |
| 数据偏移        | 指出TCP报文段的**数据起始位置**距离TCP**报文段的起始**有多远(单位 32位) | 4位 bit        |
| 保留位          | 目前置0                                                      | 6位            |
| 紧急URG         | `URGent`<br/>为1 时，表明紧急指针字段有效<br/>告诉系统：该报文有紧急数据，应尽快传送(相当于高优先级的数据)<br/>和**紧急指针**字段配合 | 1 bit          |
| 确认ACK         | Acknowledged<br/>为1时**确认号**字段才有效；<br/>连接建立后，所有传送的报文段都必须把ACK置1 | 1 bit          |
| 推送PSH         | PuSH<br/>接收 TCP收到 PSH= 1 的报文段，就尽快地交付接收应用进程<br/>而**不再等**到整个缓存都填满了后再向上交付 | 1 bit          |
| 复位RST         | ReSeT= 1 时，表明TCP连接中出现严重差错（如由于主机崩溃或其他原因）<br/>必须释放连接，然后再重新建立运输连接 | 1 bit          |
| 同步SYN         | SYN=1 表示这是一个连接请求或连接接受报文                     | 1bit           |
| 终止FIN         | FINis<br/>p用来释放一个连接。FIN = 1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。 | 1 bit          |
| 窗口            | 窗口值：从本报文的确认号算起，接收方目前允许发送方发送的数据量(单位：字节)<br/>作为接收方让发送方设置其发送窗口的依据<br/>`窗口字段明确指出了现在允许对方发送的数据量；窗口值经常动态变化` | 2 字节         |
| 检验和          | 检验和字段检验的范围包括首部和数据这两部分<br/>计算时，类似于UDP，计算时也需要加入12字节伪首部 | 2字节          |
| 紧急指针        | 仅在URG = 1 有效，指出在本报文段中紧急数据共有多少个字节<br/>（紧急数据放在本报文段数据的最前面） | 2字节          |
| 选项            | TCP 最初只有一种选项，即最大报文段长度 `MSS`(Maximum Segment Size)<br/>`MSS` 告诉对方缓存所能接收的报文段的**数据字段**的最大长度是 `MSS` 个字节<br/>**数据字段**加上 **TCP 首部**才等于整个的 TCP 报文段 | 最长可达40字节 |
| 填充            | 为了让首部长度为4字节的整数倍                                |                |

- `MSS`与窗口值没有关系

### TCP可靠传输的实现

#### 以字节为单位的滑动窗口

```
TCP的滑动窗口以字节为单位
```

```
假定A收到了B的确认分组，其窗口20字节，确认号31；——表明了B接下来期望收到的序号为31，而30及以前的数据都已经收到
```

- 发送端的发送窗口大小不能够大于窗口字段值

- 前：未来；后：已经

- 发送窗口的位置

  - 由窗口前沿和后沿共同决定；
  - 发送窗口**后沿**的变化：
    - 不动(没有收到新的确认)
    - 前移(收到了新的确认)
    - 不可能向后
  - 发送窗口**前沿**的变化：
    - 一般是前移
    - 不动
      - 不动(没有收到新的确认)
      - 收到新的确认，但是对方通知的窗口缩小
    - 向后收缩
      - 对方通知窗口缩小

  ```
  描述一个发送窗口的状态需要三个指针：P1，P2,P3
  小于P1是已发送、已确认；
  大于P3是未发送、未确认；
  P2分割了已经发送，但是不一定确认的部分
  ```

  有如下关系(单位 bytes)

$A$的发送窗口 = $P_3-P_1$

已发送但是没有收到确认 = $P_2-P_1$

允许发送但是还没发送 = $P_3-P_2$, 也叫做 **可用窗口 / 有效窗口**

##### 发送 / 接收的窗口变化分析

###### 窗口与缓存

```
发送方应用进程把字节流写入TCP的发送缓存；
接收方应用进程把从TCP的接收缓存中读取字节流；
```

###### 发送方

发送缓存用于存放

1. 发送应用程序传送给发送方TCP**准备发送**的数据
2. TCP已发送但是**未收到确认**的数据

###### 接收方

接收缓存用于存放

1. **按序**到达，但**未被应用程序接收**的数据
2. **未按序**到达的数据(TCP不把他们直接丢弃，而是先存放，之后按序传给应用程序)

### TCP握手

#### TCP连接建立

```
TCP连接建立过程叫做握手；需要在客户端、服务器之间交换三个TCP报文段
```

![img](https://images2017.cnblogs.com/blog/985821/201708/985821-20170802101806802-1497343688.png)

最初两端的TCP进程都处于CLOSED关闭状态，A主动打开连接，而B被动打开连接。（**A、B关闭状态CLOSED**——**B收听状态LISTEN——A同步已发送状态SYN-SENT——B同步收到状态SYN-RCVD——A、B连接已建立状态ESTABLISHED**）

- B的TCP服务器进程先创建传输控制块`TCB(Transmission Control Block)`，准备接受客户进程的连接请求。然后服务器进程就处于LISTEN（收听）状态，等待客户的连接请求。若有，则作出响应。
- **1**）第一次握手：**A的TCP客户进程也是首先创建传输控制块TCB，然后向B发出连接请求报文段，（首部的**同步位SYN=1**，**初始序号seq=x)，（SYN=1的报文段不能携带数据）但要消耗掉一个序号，此时TCP客户进程进入SYN-SENT（同步已发送）状态。
- **2**）第二次握手：**B收到连接请求报文段后，如同意建立连接，则向A发送确认，在确认报文段中（**SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y），测试TCP服务器进程进入SYN-RCVD（同步收到）状态；
- **3**）第三次握手：**TCP客户进程收到B的确认后，要向B给出确认报文段**（ACK=1，确认号ack=y+1，序号seq=x+1）（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。TCP连接已经建立，A进入ESTABLISHED（已建立连接）。
- 当B收到A的确认后，也进入ESTABLISHED状态。

##### 总结三次握手过程：

- **第一次握手**：起初两端都处于CLOSED关闭状态，Client将标志位SYN置为1，随机产生一个值seq=x，并将该数据包发送给Server，Client进入SYN-SENT状态，等待Server确认；
- **第二次握手**：Server收到数据包后由标志位SYN=1得知Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=x+1，随机产生一个值seq=y，并将该数据包发送给Client以确认连接请求，Server进入SYN-RCVD状态，此时操作系统为该TCP连接分配**TCP缓存和变量**；
- **第三次握手**：Client收到确认后，检查`ack`是否为x+1，`ACK`是否为1，如果正确则将标志位`ACK`置为1，`ack=y+1`，并且此时操作系统为该TCP连接分配TCP缓存和变量，并将该数据包发送给Server，Server检查ack是否为y+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client和Server就可以开始传输数据。

起初A和B都处于**CLOSED状态**——B创建TCB，处于**LISTEN状态**，等待A请求——A创建TCB，发送连接请求（SYN=1，seq=x），进入**SYN-SENT状态**——B收到连接请求，向A发送确认（SYN=ACK=1，确认号ack=x+1，初始序号seq=y），进入**SYN-RCVD状态**——A收到B的确认后，给B发出确认（ACK=1，ack=y+1，seq=x+1），A进入**ESTABLISHED状态**——B收到A的确认后，进入ESTABLISHED状态。

###### **TCB** **传输控制块**

Transmission Control Block

```
存储每一个连接中的重要信息，如TCP连接表，到发送和接收缓存的指针，到重传队列的指针，当前的发送和接收序号。
```

###### 为什么A还要发送一次确认呢？可以二次握手吗？

　　答：**主要为了防止已失效的连接请求报文段突然又传送到了B，因而产生错误**。如A发出连接请求，但因连接请求报文丢失而未收到确认，于是A再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，A工发出了两个连接请求报文段，其中第一个丢失，第二个到达了B，但是第一个丢失的报文段只是在**某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达B**，此时B误认为A又发出一次新的连接请求，于是就向A发出确认报文段，同意建立连接，不采用三次握手，`只要B发出确认，就建立新的连接了`，此时A**不理睬**B的确认且不发送数据，则B一致等待A发送数据，浪费资源。

#### TCP连接释放

```
假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说"我Client端没有数据要发给你了"，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，"告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息"。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。
当Server端确定数据已发送完成，则向Client端发送FIN报文，"告诉Client端，好了，我这边数据发完了，准备好关闭连接了"。Client端收到FIN报文后，"就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，"就知道可以断开连接了"。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！
```

![img](https://images2017.cnblogs.com/blog/985821/201708/985821-20170802101823505-1177747613.png)

 数据传输结束后，通信的双方都可释放连接，A和B都处于ESTABLISHED状态。

（**A、B连接建立状态ESTABLISHED**——**A终止等待1状态FIN-WAIT-1**——**B关闭等待状态CLOSE-WAIT**——**A终止等待2状态FIN-WAIT-2**——**B最后确认状态LAST-ACK**——**A时间等待状态TIME-WAIT**——**B、A关闭状态CLOSED**）

- 1）A的应用进程先向其TCP发出连接释放报文段（**FIN=1，序号seq=u**），并停止再发送数据，主动关闭TCP连接，进入FIN-WAIT-1（终止等待1）状态，等待B的确认。
- 2）B收到连接释放报文段后即发出确认报文段，（**ACK=1，确认号ack=u+1，序号seq=v**），B进入CLOSE-WAIT（关闭等待）状态，此时的TCP处于**半关闭状态**，A到B的连接释放。
- 3）A收到B的确认后，进入FIN-WAIT-2（终止等待2）状态，等待B发出的连接释放报文段。
- 4）B没有要向A发出的数据，B发出连接释放报文段（**FIN=1，ACK=1，序号seq=w，确认号ack=u+1），**B进入LAST-ACK（最后确认）状态，等待A的确认。
- 5）A收到B的连接释放报文段后，对此发出确认报文段（**ACK=1，seq=u+1，ack=w+1**），A进入TIME-WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，A才进入CLOSED状态。

（2）总结四次挥手过程：

起初A和B处于**ESTABLISHED状态**——A发出连接释放报文段并处于**FIN-WAIT-1状态**——B发出确认报文段且进入**CLOSE-WAIT状态**——A收到确认后，进入**FIN-WAIT-2状态**，等待B的连接释放报文段——B没有要向A发出的数据，B发出连接释放报文段且进入**LAST-ACK状态**——A发出确认报文段且进入**TIME-WAIT状态**——B收到确认报文段后进入**CLOSED状态**——A经过等待计时器时间2MSL后，进入**CLOSED状态**。

（3）为什么A在TIME-WAIT状态必须等待2MSL的时间？

MSL最长报文段寿命Maximum Segment Lifetime，MSL=2

答：　　两个理由：**1 ** **）保证** **A** **发送的最后一个****ACK** **报文段能够到达** **B** **。** **2** **）防止“已失效的连接请求报文段”出现在本连接中。**

- 1）这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，B超时重传FIN+ACK报文段，而A能在2MSL时间内收到这个重传的FIN+ACK报文段，接着A重传一次确认，重新启动2MSL计时器，最后A和B都进入到CLOSED状态，**若A在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到B重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则B无法正常进入到CLOSED状态。**
- 2）A在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。

（4）为什么连接的时候是三次握手，关闭的时候却是四次握手？

答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端**所有的报文都发送完**了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

（5）为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？

答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。